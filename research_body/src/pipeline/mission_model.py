"""
PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
MISSION MODEL  Data Structures for Research Missions
PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP

PURPOSE:
    This module defines the core data structures that represent a research mission.
    Think of it as the "nervous system's message format"  how information
    flows between organs in a standardized way.

CORE CONCEPTS:
    " MissionRequest: The input specification (what to research)
    " MissionPlan: The Planner's breakdown of tasks
    " MissionResult: The final output after pipeline completion
    " Task: Individual units of work (fetch, clean, summarize)

DATA FLOW:
    User Input � MissionRequest � PlannerAgent � MissionPlan
              � Pipeline Execution � MissionResult � Notion/Archive

TEACHING GOALS:
    This module demonstrates:
    1. Structured data modeling
    2. Type safety and validation
    3. Serialization for persistence
    4. Clean interfaces between components

DESIGN PRINCIPLES:
    " Immutable data structures where possible
    " Clear validation rules
    " Rich error messages
    " Serializable to JSON/YAML for storage

FUTURE EXTENSIONS:
    " Mission templates for common research patterns
    " Mission composition (sub-missions)
    " Priority and scheduling metadata
    " Resource constraints (time, cost, API limits)

PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
"""


from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum


# ═══════════════════════════════════════════════════════════════════════════
# ENUMS FOR TYPE SAFETY
# ═══════════════════════════════════════════════════════════════════════════

class MissionStatus(Enum):
    """Status of a mission throughout its lifecycle."""
    PENDING = "pending"
    PLANNING = "planning"
    FETCHING = "fetching"
    CLEANING = "cleaning"
    SUMMARIZING = "summarizing"
    WRITING = "writing"
    COMPLETED = "completed"
    FAILED = "failed"


class TaskType(Enum):
    """Types of tasks in the pipeline."""
    FETCH = "fetch"
    CLEAN = "clean"
    SUMMARIZE = "summarize"
    WRITE = "write"


# ═══════════════════════════════════════════════════════════════════════════
# CORE DATA STRUCTURES
# ═══════════════════════════════════════════════════════════════════════════

@dataclass
class MissionRequest:
    """
    The input specification for a research mission.

    This is what the user provides to initiate research.
    Think of it as the "mission briefing" given to the organism.

    Example:
        mission = MissionRequest(
            query="Research wildfire trends in California 2024",
            max_sources=5,
            summary_style="detailed"
        )
    """
    # Required fields
    query: str  # The research question or topic

    # Optional configuration
    max_sources: int = 5  # How many URLs to fetch
    summary_style: str = "balanced"  # "brief", "balanced", or "detailed"
    target_audience: str = "general"  # Who is this research for?

    # Metadata
    created_at: datetime = field(default_factory=datetime.now)
    mission_id: Optional[str] = None  # Generated UUID for tracking

    def __post_init__(self):
        """Validate the mission request."""
        if not self.query or not self.query.strip():
            raise ValueError("Mission query cannot be empty")

        if self.max_sources < 1:
            raise ValueError("Must fetch at least 1 source")

        valid_styles = ["brief", "balanced", "detailed"]
        if self.summary_style not in valid_styles:
            raise ValueError(f"summary_style must be one of {valid_styles}")


@dataclass
class Task:
    """
    A single unit of work in the pipeline.

    Tasks are generated by the PlannerAgent and executed by tools.
    """
    task_type: TaskType
    url: Optional[str] = None  # For FETCH tasks
    content: Optional[str] = None  # Input content for processing
    result: Optional[Any] = None  # Output after execution
    status: str = "pending"  # "pending", "in_progress", "completed", "failed"
    error: Optional[str] = None  # Error message if failed
    metadata: Dict[str, Any] = field(default_factory=dict)  # Extra info


@dataclass
class MissionPlan:
    """
    The Planner's breakdown of a mission into tasks.

    Generated by PlannerAgent based on MissionRequest.
    """
    mission_id: str
    tasks: List[Task] = field(default_factory=list)
    reasoning: str = ""  # Why this plan was chosen
    estimated_time: Optional[float] = None  # Estimated seconds
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class MissionResult:
    """
    The final output after pipeline completion.

    Contains all summaries, metadata, and execution logs.
    """
    mission_id: str
    request: MissionRequest
    plan: MissionPlan

    # Results
    summary: Optional[str] = None  # Final synthesized summary
    sources_fetched: List[str] = field(default_factory=list)  # URLs
    metadata: Dict[str, Any] = field(default_factory=dict)

    # Execution tracking
    status: MissionStatus = MissionStatus.PENDING
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error: Optional[str] = None

    @property
    def duration(self) -> Optional[float]:
        """Calculate mission duration in seconds."""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None


# ═══════════════════════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════

def create_mission_request(query: str, **kwargs) -> MissionRequest:
    """
    Factory function for creating mission requests with validation.

    Example:
        mission = create_mission_request(
            "Research AI safety trends",
            max_sources=10,
            summary_style="detailed"
        )
    """
    import uuid
    mission_id = str(uuid.uuid4())
    return MissionRequest(query=query, mission_id=mission_id, **kwargs)


# ═══════════════════════════════════════════════════════════════════════════
# TEACHING NOTES
# ═══════════════════════════════════════════════════════════════════════════

"""
Why use dataclasses?
    • Automatic __init__, __repr__, __eq__
    • Type hints for clarity and IDE support
    • Immutable with frozen=True (if needed)
    • Easy serialization to JSON

Why use Enums?
    • Type safety (can't use invalid status strings)
    • Autocomplete in IDEs
    • Self-documenting code
    • Easy to extend

Data Flow Example:
    1. User creates MissionRequest("Research AI")
    2. PlannerAgent generates MissionPlan with Tasks
    3. FlowController executes each Task
    4. Results collected in MissionResult
    5. MissionResult stored in logger and Notion
"""
